import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a '" + methodName + "' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator");
      define(Gp, iteratorSymbol, function() {
        return this;
      });
      define(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@ffmpeg/ffmpeg/src/config.js
var require_config = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/src/config.js"(exports, module) {
    module.exports = {
      defaultArgs: [
        /* args[0] is always the binary path */
        "./ffmpeg",
        /* Disable interaction mode */
        "-nostdin",
        /* Force to override output file */
        "-y"
      ],
      baseOptions: {
        /* Flag to turn on/off log messages in console */
        log: false,
        /*
         * Custom logger to get ffmpeg.wasm output messages.
         * a sample logger looks like this:
         *
         * ```
         * logger = ({ type, message }) => {
         *   console.log(type, message);
         * }
         * ```
         *
         * type can be one of following:
         *
         * info: internal workflow debug messages
         * fferr: ffmpeg native stderr output
         * ffout: ffmpeg native stdout output
         */
        logger: () => {
        },
        /*
         * Progress handler to get current progress of ffmpeg command.
         * a sample progress handler looks like this:
         *
         * ```
         * progress = ({ ratio }) => {
         *   console.log(ratio);
         * }
         * ```
         *
         * ratio is a float number between 0 to 1.
         */
        progress: () => {
        },
        /*
         * Path to find/download ffmpeg.wasm-core,
         * this value should be overwriten by `defaultOptions` in
         * each environment.
         */
        corePath: ""
      }
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js
var require_parseArgs = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js"(exports, module) {
    module.exports = (Core, args) => {
      const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);
      args.forEach((s, idx) => {
        const sz = Core.lengthBytesUTF8(s) + 1;
        const buf = Core._malloc(sz);
        Core.stringToUTF8(s, buf, sz);
        Core.setValue(argsPtr + Uint32Array.BYTES_PER_ELEMENT * idx, buf, "i32");
      });
      return [args.length, argsPtr];
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/package.json
var require_package = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/package.json"(exports, module) {
    module.exports = {
      name: "@ffmpeg/ffmpeg",
      version: "0.11.6",
      description: "FFmpeg WebAssembly version",
      main: "src/index.js",
      types: "src/index.d.ts",
      directories: {
        example: "examples"
      },
      scripts: {
        start: "node scripts/server.js",
        "start:worker": "node scripts/worker-server.js",
        build: "rimraf dist && webpack --config scripts/webpack.config.prod.js",
        "build:worker": "rimraf dist && webpack --config scripts/webpack.config.worker.prod.js",
        prepublishOnly: "npm run build",
        lint: "eslint src",
        wait: "rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js",
        test: "npm-run-all -p -r start test:all",
        "test:all": "npm-run-all wait test:browser:ffmpeg test:node:all",
        "test:node": "node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js",
        "test:node:all": "npm run test:node -- ./tests/*.test.js",
        "test:browser": "mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000",
        "test:browser:ffmpeg": "npm run test:browser -- -f ./tests/ffmpeg.test.html"
      },
      browser: {
        "./src/node/index.js": "./src/browser/index.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/ffmpegwasm/ffmpeg.wasm.git"
      },
      keywords: [
        "ffmpeg",
        "WebAssembly",
        "video"
      ],
      author: "Jerome Wu <jeromewus@gmail.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/ffmpegwasm/ffmpeg.wasm/issues"
      },
      engines: {
        node: ">=12.16.1"
      },
      homepage: "https://github.com/ffmpegwasm/ffmpeg.wasm#readme",
      dependencies: {
        "is-url": "^1.2.4",
        "node-fetch": "^2.6.1",
        "regenerator-runtime": "^0.13.7",
        "resolve-url": "^0.2.1"
      },
      devDependencies: {
        "@babel/core": "^7.12.3",
        "@babel/preset-env": "^7.12.1",
        "@ffmpeg/core": "^0.11.0",
        "@types/emscripten": "^1.39.4",
        "babel-eslint": "^10.1.0",
        "babel-loader": "^8.1.0",
        chai: "^4.2.0",
        cors: "^2.8.5",
        eslint: "^7.12.1",
        "eslint-config-airbnb-base": "^14.1.0",
        "eslint-plugin-import": "^2.22.1",
        express: "^4.17.1",
        mocha: "^8.2.1",
        "mocha-headless-chrome": "^2.0.3",
        "npm-run-all": "^4.1.5",
        "wait-on": "^5.3.0",
        webpack: "^5.3.2",
        "webpack-cli": "^4.1.0",
        "webpack-dev-middleware": "^4.0.0"
      }
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js
var import_package, corePath, defaultOptions_default;
var init_defaultOptions = __esm({
  "node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js"() {
    import_package = __toESM(require_package());
    corePath = typeof process !== "undefined" && true ? new URL("/node_modules/@ffmpeg/core/dist/ffmpeg-core.js", import.meta.url).href : `https://unpkg.com/@ffmpeg/core@${import_package.default.devDependencies["@ffmpeg/core"].substring(1)}/dist/ffmpeg-core.js`;
    defaultOptions_default = { corePath };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/utils/log.js
var require_log = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/src/utils/log.js"(exports, module) {
    var logging = false;
    var customLogger = () => {
    };
    var setLogging = (_logging) => {
      logging = _logging;
    };
    var setCustomLogger = (logger) => {
      customLogger = logger;
    };
    var log2 = (type, message) => {
      customLogger({ type, message });
      if (logging) {
        console.log(`[${type}] ${message}`);
      }
    };
    module.exports = {
      logging,
      setLogging,
      setCustomLogger,
      log: log2
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/utils/errors.js
var require_errors = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/src/utils/errors.js"(exports, module) {
    var CREATE_FFMPEG_CORE_IS_NOT_DEFINED2 = (corePath2) => `
createFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${corePath2}. Use another URL when calling createFFmpeg():

const ffmpeg = createFFmpeg({
  corePath: 'http://localhost:3000/ffmpeg-core.js',
});
`;
    module.exports = {
      CREATE_FFMPEG_CORE_IS_NOT_DEFINED: CREATE_FFMPEG_CORE_IS_NOT_DEFINED2
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js
var import_log, import_errors, toBlobURL, getCreateFFmpegCore;
var init_getCreateFFmpegCore = __esm({
  "node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js"() {
    import_log = __toESM(require_log());
    import_errors = __toESM(require_errors());
    toBlobURL = async (url, mimeType) => {
      (0, import_log.log)("info", `fetch ${url}`);
      const buf = await (await fetch(url)).arrayBuffer();
      (0, import_log.log)("info", `${url} file size = ${buf.byteLength} bytes`);
      const blob = new Blob([buf], { type: mimeType });
      const blobURL = URL.createObjectURL(blob);
      (0, import_log.log)("info", `${url} blob URL = ${blobURL}`);
      return blobURL;
    };
    getCreateFFmpegCore = async ({
      corePath: _corePath,
      workerPath: _workerPath,
      wasmPath: _wasmPath
    }) => {
      if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
        if (typeof _corePath !== "string") {
          throw Error("corePath should be a string!");
        }
        const coreRemotePath2 = new URL(_corePath, import.meta.url).href;
        const corePath3 = await toBlobURL(
          coreRemotePath2,
          "application/javascript"
        );
        const wasmPath2 = await toBlobURL(
          _wasmPath !== void 0 ? _wasmPath : coreRemotePath2.replace("ffmpeg-core.js", "ffmpeg-core.wasm"),
          "application/wasm"
        );
        const workerPath2 = await toBlobURL(
          _workerPath !== void 0 ? _workerPath : coreRemotePath2.replace("ffmpeg-core.js", "ffmpeg-core.worker.js"),
          "application/javascript"
        );
        if (typeof createFFmpegCore === "undefined") {
          return new Promise((resolve) => {
            globalThis.importScripts(corePath3);
            if (typeof createFFmpegCore === "undefined") {
              throw Error((0, import_errors.CREATE_FFMPEG_CORE_IS_NOT_DEFINED)(coreRemotePath2));
            }
            (0, import_log.log)("info", "ffmpeg-core.js script loaded");
            resolve({
              createFFmpegCore,
              corePath: corePath3,
              wasmPath: wasmPath2,
              workerPath: workerPath2
            });
          });
        }
        (0, import_log.log)("info", "ffmpeg-core.js script is loaded already");
        return Promise.resolve({
          createFFmpegCore,
          corePath: corePath3,
          wasmPath: wasmPath2,
          workerPath: workerPath2
        });
      }
      if (typeof _corePath !== "string") {
        throw Error("corePath should be a string!");
      }
      const coreRemotePath = new URL(_corePath, import.meta.url).href;
      const corePath2 = await toBlobURL(
        coreRemotePath,
        "application/javascript"
      );
      const wasmPath = await toBlobURL(
        _wasmPath !== void 0 ? _wasmPath : coreRemotePath.replace("ffmpeg-core.js", "ffmpeg-core.wasm"),
        "application/wasm"
      );
      const workerPath = await toBlobURL(
        _workerPath !== void 0 ? _workerPath : coreRemotePath.replace("ffmpeg-core.js", "ffmpeg-core.worker.js"),
        "application/javascript"
      );
      if (typeof createFFmpegCore === "undefined") {
        return new Promise((resolve) => {
          const script = document.createElement("script");
          const eventHandler = () => {
            script.removeEventListener("load", eventHandler);
            if (typeof createFFmpegCore === "undefined") {
              throw Error((0, import_errors.CREATE_FFMPEG_CORE_IS_NOT_DEFINED)(coreRemotePath));
            }
            (0, import_log.log)("info", "ffmpeg-core.js script loaded");
            resolve({
              createFFmpegCore,
              corePath: corePath2,
              wasmPath,
              workerPath
            });
          };
          script.src = corePath2;
          script.type = "text/javascript";
          script.addEventListener("load", eventHandler);
          document.getElementsByTagName("head")[0].appendChild(script);
        });
      }
      (0, import_log.log)("info", "ffmpeg-core.js script is loaded already");
      return Promise.resolve({
        createFFmpegCore,
        corePath: corePath2,
        wasmPath,
        workerPath
      });
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js
var readFromBlobOrFile, fetchFile;
var init_fetchFile = __esm({
  "node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js"() {
    readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {
      const fileReader = new FileReader();
      fileReader.onload = () => {
        resolve(fileReader.result);
      };
      fileReader.onerror = ({ target: { error: { code } } }) => {
        reject(Error(`File could not be read! Code=${code}`));
      };
      fileReader.readAsArrayBuffer(blob);
    });
    fetchFile = async (_data) => {
      let data = _data;
      if (typeof _data === "undefined") {
        return new Uint8Array();
      }
      if (typeof _data === "string") {
        if (/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(_data)) {
          data = atob(_data.split(",")[1]).split("").map((c) => c.charCodeAt(0));
        } else {
          const res = await fetch(new URL(_data, import.meta.url).href);
          data = await res.arrayBuffer();
        }
      } else if (_data instanceof File || _data instanceof Blob) {
        data = await readFromBlobOrFile(_data);
      }
      return new Uint8Array(data);
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  defaultOptions: () => defaultOptions_default,
  fetchFile: () => fetchFile,
  getCreateFFmpegCore: () => getCreateFFmpegCore
});
var init_browser = __esm({
  "node_modules/@ffmpeg/ffmpeg/src/browser/index.js"() {
    init_defaultOptions();
    init_getCreateFFmpegCore();
    init_fetchFile();
  }
});

// node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js
var require_createFFmpeg = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"(exports, module) {
    var { defaultArgs, baseOptions } = require_config();
    var parseArgs = require_parseArgs();
    var { defaultOptions, getCreateFFmpegCore: getCreateFFmpegCore2 } = (init_browser(), __toCommonJS(browser_exports));
    var { version } = require_package();
    var NO_LOAD = Error("ffmpeg.wasm is not ready, make sure you have completed load().");
    module.exports = (_options = {}) => {
      const {
        log: optLog,
        logger,
        progress: optProgress,
        ...options
      } = {
        ...baseOptions,
        ...defaultOptions,
        ..._options
      };
      let Core = null;
      let ffmpeg = null;
      let runResolve = null;
      let runReject = null;
      let running = false;
      let customLogger = () => {
      };
      let logging = optLog;
      let progress = optProgress;
      let duration = 0;
      let frames = 0;
      let readFrames = false;
      let ratio = 0;
      const detectCompletion = (message) => {
        if (message === "FFMPEG_END" && runResolve !== null) {
          runResolve();
          runResolve = null;
          runReject = null;
          running = false;
        }
      };
      const log2 = (type, message) => {
        customLogger({ type, message });
        if (logging) {
          console.log(`[${type}] ${message}`);
        }
      };
      const ts2sec = (ts) => {
        const [h, m, s] = ts.split(":");
        return parseFloat(h) * 60 * 60 + parseFloat(m) * 60 + parseFloat(s);
      };
      const parseProgress = (message, prog) => {
        if (typeof message === "string") {
          if (message.startsWith("  Duration")) {
            const ts = message.split(", ")[0].split(": ")[1];
            const d = ts2sec(ts);
            prog({ duration: d, ratio });
            if (duration === 0 || duration > d) {
              duration = d;
              readFrames = true;
            }
          } else if (readFrames && message.startsWith("    Stream")) {
            const match = message.match(/([\d.]+) fps/);
            if (match) {
              const fps = parseFloat(match[1]);
              frames = duration * fps;
            } else {
              frames = 0;
            }
            readFrames = false;
          } else if (message.startsWith("frame") || message.startsWith("size")) {
            const ts = message.split("time=")[1].split(" ")[0];
            const t = ts2sec(ts);
            const match = message.match(/frame=\s*(\d+)/);
            if (frames && match) {
              const f = parseFloat(match[1]);
              ratio = Math.min(f / frames, 1);
            } else {
              ratio = t / duration;
            }
            prog({ ratio, time: t });
          } else if (message.startsWith("video:")) {
            prog({ ratio: 1 });
            duration = 0;
          }
        }
      };
      const parseMessage = ({ type, message }) => {
        log2(type, message);
        parseProgress(message, progress);
        detectCompletion(message);
      };
      const load = async () => {
        log2("info", "load ffmpeg-core");
        if (Core === null) {
          log2("info", "loading ffmpeg-core");
          const {
            createFFmpegCore: createFFmpegCore2,
            corePath: corePath2,
            workerPath,
            wasmPath
          } = await getCreateFFmpegCore2(options);
          Core = await createFFmpegCore2({
            /*
             * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue
             * as there is no document.currentScript in the context of content_scripts
             */
            mainScriptUrlOrBlob: corePath2,
            printErr: (message) => parseMessage({ type: "fferr", message }),
            print: (message) => parseMessage({ type: "ffout", message }),
            /*
             * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).
             * It is critical for browser environment and we override both wasm and worker paths
             * as we are using blob URL instead of original URL to avoid cross origin issues.
             */
            locateFile: (path, prefix) => {
              if (typeof window !== "undefined" || typeof WorkerGlobalScope !== "undefined") {
                if (typeof wasmPath !== "undefined" && path.endsWith("ffmpeg-core.wasm")) {
                  return wasmPath;
                }
                if (typeof workerPath !== "undefined" && path.endsWith("ffmpeg-core.worker.js")) {
                  return workerPath;
                }
              }
              return prefix + path;
            }
          });
          ffmpeg = Core.cwrap(options.mainName || "proxy_main", "number", ["number", "number"]);
          log2("info", "ffmpeg-core loaded");
        } else {
          throw Error("ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.");
        }
      };
      const isLoaded = () => Core !== null;
      const run = (..._args) => {
        log2("info", `run ffmpeg command: ${_args.join(" ")}`);
        if (Core === null) {
          throw NO_LOAD;
        } else if (running) {
          throw Error("ffmpeg.wasm can only run one command at a time");
        } else {
          running = true;
          return new Promise((resolve, reject) => {
            const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);
            runResolve = resolve;
            runReject = reject;
            ffmpeg(...parseArgs(Core, args));
          });
        }
      };
      const FS = (method, ...args) => {
        log2("info", `run FS.${method} ${args.map((arg) => typeof arg === "string" ? arg : `<${arg.length} bytes binary file>`).join(" ")}`);
        if (Core === null) {
          throw NO_LOAD;
        } else {
          let ret = null;
          try {
            ret = Core.FS[method](...args);
          } catch (e) {
            if (method === "readdir") {
              throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);
            } else if (method === "readFile") {
              throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);
            } else {
              throw Error("Oops, something went wrong in FS operation.");
            }
          }
          return ret;
        }
      };
      const exit = () => {
        if (Core === null) {
          throw NO_LOAD;
        } else {
          if (runReject) {
            runReject("ffmpeg has exited");
          }
          running = false;
          try {
            Core.exit(1);
          } catch (err) {
            log2(err.message);
            if (runReject) {
              runReject(err);
            }
          } finally {
            Core = null;
            ffmpeg = null;
            runResolve = null;
            runReject = null;
          }
        }
      };
      const setProgress = (_progress) => {
        progress = _progress;
      };
      const setLogger = (_logger) => {
        customLogger = _logger;
      };
      const setLogging = (_logging) => {
        logging = _logging;
      };
      log2("info", `use ffmpeg.wasm v${version}`);
      return {
        setProgress,
        setLogger,
        setLogging,
        load,
        isLoaded,
        run,
        exit,
        FS
      };
    };
  }
});

// node_modules/@ffmpeg/ffmpeg/src/index.js
var require_src = __commonJS({
  "node_modules/@ffmpeg/ffmpeg/src/index.js"(exports, module) {
    require_runtime();
    var createFFmpeg = require_createFFmpeg();
    var { fetchFile: fetchFile2 } = (init_browser(), __toCommonJS(browser_exports));
    module.exports = {
      /*
       * Create ffmpeg instance.
       * Each ffmpeg instance owns an isolated MEMFS and works
       * independently.
       *
       * For example:
       *
       * ```
       * const ffmpeg = createFFmpeg({
       *  log: true,
       *  logger: () => {},
       *  progress: () => {},
       *  corePath: '',
       * })
       * ```
       *
       * For the usage of these four arguments, check config.js
       *
       */
      createFFmpeg,
      /*
       * Helper function for fetching files from various resource.
       * Sometimes the video/audio file you want to process may located
       * in a remote URL and somewhere in your local file system.
       *
       * This helper function helps you to fetch to file and return an
       * Uint8Array variable for ffmpeg.wasm to consume.
       *
       */
      fetchFile: fetchFile2
    };
  }
});
export default require_src();
//# sourceMappingURL=@ffmpeg_ffmpeg.js.map
